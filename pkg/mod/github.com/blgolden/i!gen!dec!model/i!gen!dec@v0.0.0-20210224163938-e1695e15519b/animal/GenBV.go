// GenBV
/*
Copyright 2021 Bruce Golden and Matt Spangler

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
package animal

import (
	//"fmt"
	"math/rand"

	//"os"

	"gonum.org/v1/gonum/mat"
)

var Rng *rand.Rand

// Generate a foundation animal - sire and dam unknown
func GenFoundation(a *Animal, gvCholesky mat.Cholesky, rvCholesky mat.Cholesky) {

	//fmt.Printf("Animal: %d\n", a.Id)
	//fmt.Printf("Cholesky order: %d\n", gvCholesky.Size())
	_, col := gvCholesky.Dims()
	v := make([]float64, col)
	for i := range v {
		v[i] = Rng.NormFloat64()
	}
	b := mat.NewVecDense(len(v), v)
	var t mat.TriDense
	gvCholesky.LTo(&t)

	var bv mat.VecDense
	bv.MulVec(&t, b)
	a.BreedingValue = &bv

	_, col = rvCholesky.Dims()
	v = make([]float64, col)
	for i := range v {
		v[i] = Rng.NormFloat64()
	}
	rv := mat.NewVecDense(len(v), v)
	var tr mat.TriDense
	rvCholesky.LTo(&tr)
	var res mat.VecDense
	res.MulVec(&tr, rv)
	a.Residual = &res

	//fmt.Println("breeding values:\n")
	//fmt.Println(a.BreedingValue.RawVector())
	//fmt.Println(a.Residual.RawVector())
	//fmt.Printf("%v %v\n", a.BreedingValue.AtVec(0), a.BreedingValue.AtVec(1))

	//GenFoundationBreedComposition(a) // Foundation animals' breed composition random generator
}

// Generate the breed composition of a foundation animal from the CowHerdBreedComposition: key
func GenFoundationBreedComposition(a *Animal) {

	p := rand.Float64()

	for i := range FoundationCowHerdBreedCompositionTable {
		if p <= FoundationCowHerdBreedCompositionTable[i].Proportion {
			a.BreedComposition = make(map[string]float64)
			for key, element := range FoundationCowHerdBreedCompositionTable[i].BreedProportions {
				a.BreedComposition[key] = element
			}
			break
		}
	}
	//fmt.Println("LOC B", a.Id, a.BreedComposition)

	return
}

// Generate the breed composition of the initial bull battery animal from the BullBatteryBreedComposition: key
func GenBullBatteryBreedComposition(a *Animal) {

	p := rand.Float64()

	for i := range BullBatteryBreedCompositionTable {
		if p <= BullBatteryBreedCompositionTable[i].Proportion {
			a.BreedComposition = make(map[string]float64)
			for key, element := range BullBatteryBreedCompositionTable[i].BreedProportions {
				a.BreedComposition[key] = element
			}
			break
		}
	}

	return
}

// Return the string of codes generated by a number usually random
func WhatSex(i int) (code string) {
	if i == 0 {
		code = Steer
	} else {
		code = Heifer
	}

	return code
}

// Generate an animal from a mating
// Determine if the heifer or calf died in calving
func GenFromMating(a *Animal, year int, gvCholesky mat.Cholesky, rvCholesky mat.Cholesky) {

	// a is the cow bred

	var n Animal
	n.Id = AnimalId(len(Records)) + 1 // There is no ID = 0.  That is the unknown
	n.Sire = a.BreedingRecords[len(a.BreedingRecords)-1].Bull
	n.Dam = a.Id
	n.BirthDate = a.BreedingRecords[len(a.BreedingRecords)-1].CalvingDate
	n.YearBorn = year
	n.HerdName = a.HerdName
	sx := rand.Intn(2)
	n.Sex = WhatSex(sx)

	// Calculate parent average BV
	_, col := gvCholesky.Dims()
	pAve := mat.NewVecDense(col, nil)
	sbv := Records[n.Sire].BreedingValue
	dbv := a.BreedingValue
	pAve.AddVec(sbv, dbv)

	// Generate the medelian sample
	v := make([]float64, col)
	for i := range v {
		v[i] = Rng.NormFloat64()
	}
	b := mat.NewVecDense(col, v)
	var t mat.TriDense
	gvCholesky.LTo(&t)

	var c mat.VecDense
	c.MulVec(&t, b)
	var mendleSample mat.VecDense
	mendleSample.MulVec(&t, b)

	// Set the new animal's BV
	newBV := mat.NewVecDense(col, nil)
	for i := 0; i < mendleSample.Len(); i++ {
		// sqrt(.5) = .707106781
		bv := mendleSample.At(i, 0)*.707106781 + pAve.At(i, 0)*.5
		newBV.SetVec(i, bv) // Calculate the average
	}
	n.BreedingValue = newBV

	_, col = rvCholesky.Dims()
	r := make([]float64, col)
	for i := range r {
		r[i] = Rng.NormFloat64()
	}
	d := mat.NewVecDense(col, r)
	var tr mat.TriDense
	rvCholesky.LTo(&tr)

	newR := mat.NewVecDense(col, nil)
	newR.MulVec(&tr, d)
	n.Residual = newR

	SetBreedComposition(&n) // Determine the new animals breed composition

	diedCalving(a, &n)

	Records = append(Records, n)

	Herds[n.HerdName].SumBirthDates[year] += float64(n.BirthDate)
	Herds[n.HerdName].NBorn[year] += 1.
}

// Determine an animal's breed composition from sire and dam
func SetBreedComposition(a *Animal) {

	sire := Records[a.Sire]
	dam := Records[a.Dam]

	a.BreedComposition = make(map[string]float64)

	for key, value := range sire.BreedComposition {
		a.BreedComposition[key] += value * .5
	}
	for key, value := range dam.BreedComposition {
		var s float64
		if val, ok := sire.BreedComposition[key]; ok {
			s = val
		}
		b := s*.5 + value*.5
		a.BreedComposition[key] = b
	}
	return
}
